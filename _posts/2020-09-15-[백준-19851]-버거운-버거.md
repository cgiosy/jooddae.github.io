---
layout: post
title:  "[백준 19851] 버거운 버거"
subheading: hello world!
author: JooDdae
categories: PS
banner: https://bit.ly/32PAjtM
tags: lazyprop
---

## 문제 링크
[https://www.acmicpc.net/problem/19851][19851]


## 문제 출처
2020 서울대학교 프로그래밍 경시대회 - Division 1 D

## 사용 알고리즘
느리게 갱신되는 세그먼트 트리

## 시간복잡도
O(QlogN)

## 풀이
우선 뒤집는 1번쿼리가 없다고 생각하고 문제를 풀어보자.

[16993.연속합과 쿼리][16993]와 같이 세그먼트 트리의 원소를 여러개 선언할 것이다. 첫번째는 L, 왼쪽에 몇개의 여는 괄호를 추가해야 그 구간이 올바른 괄호쌍이 되는지, 두번째는 R, 오른쪽에 몇개의 닫는 괄호를 추가해야 그 구간이 올바른 괄호쌍이 되는지의 값이다. 이 값을 구간에서 구할 수 있게되면 (구간의 길이) + L + R 이 정답이다. 하지만 우리는 아직 1번 쿼리를 생각하지 않았다.

그 방법은 L과 R을 2개씩 저장하는 것이다. 첫번째 L, R는 그대로, 두번째 L, R은 초기값만 첫번째 L, R과 반대로 하는 것이다. 그 뒤에 세그먼트 트리를 갱신할때 부모의 첫번째 L, R은 첫번째 L, R로 만들고 두번째 L, R은 두번째 L, R으로 만드는 것이다. 구간 [l, r]의 두번째 L, R에는 [l, r]에 1번 쿼리를 적용했을때의 값이 들어있기 때문에 1번 쿼리가 들어오면 [l, r]구간의 첫번째 L, R과 두번째 L, R을 바꾸는 연산을 해서 해결할 수 있다.

여담으로, 이 문제의 코드를 약간만 수정해서 17407. 괄호 문자열과 쿼리를 풀 수 있다.

## 전체 코드
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

#define mid ((l + r) >> 1)

struct Node{
	int l[2], r[2], lz;
}t[4004004];

int n, q;
string s;

void lazy_update(int node, int l, int r){
	if(t[node].lz){
		swap(t[node].l[0], t[node].l[1]), swap(t[node].r[0], t[node].r[1]);
		if(l != r) t[node*2].lz ^= t[node].lz, t[node*2+1].lz ^= t[node].lz;
		t[node].lz = 0;
	}
}

int main(){
	ios_base::sync_with_stdio(0);cin.tie(0);
	cin >> n >> s >> q;
	build();

	while(q--){
		int a, l, r; cin >> a >> l >> r;
		if(a == 1){
			update(l, r);
		}else{
			Node k = find(l, r);
			cout << (r - l + 1) + k.l[0] + k.r[0] << "\n";
		}
	}
}
```

[19851]: https://www.acmicpc.net/problem/19851
[16993]: https://www.acmicpc.net/problem/16993
